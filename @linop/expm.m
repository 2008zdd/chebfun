function u = expm(L,t,u0)
% EXPM   Exponential of a linop.



% E = EXPM(A) returns a linop representing the exponential operator
% generated by A. The linop A should have boundary conditions appropriate
% for its definition, or else usage of E may be nonconvergent or
% unexpected.
%
% Note that operations on linops clear out boundary conditions, so you
% must reassign them before calling EXPM. Homogeneous (zero) boundary
% values are used, even if they are specified otherwise.
%
% EXAMPLE: Heat equation
% d = domain(-1,1);  x = chebfun('x',d);
% D = diff(d);  A = D^2;  bc = 'dirichlet';
% f = exp(-20*(x+0.3).^2);
% clf, plot(f,'r'), hold on, c = [0.8 0 0];
% for t = [0.001 0.01 0.1 0.5 1]
%    E = expm(t*A & bc);
%    plot(E*f,'color',c),  c = 0.5*c;
% end
%
% See also EXPM, CHEBOP/AND, CHEBOP/SUBSASGN.

% Copyright 2011 by The University of Oxford and The Chebfun Developers.
% See http://www.maths.ox.ac.uk/chebfun/ for Chebfun information.


discType = L.discretizer;
isFun = isFunVariable(L); 

%% Set up the discretisation:
if ( isa(discType, 'function_handle') )
    % Create a discretization object
    disc = discType(L);  
    
    % Merge domains of the operator and the initial condition.
    disc = mergeDomains(disc,u0.domain); 
    
    % Set the allowed discretisation lengths: (TODO: A preference?)
    dimVals = floor(2.^[5 6 7 8 8.5 9 9.5 10 10.5 11]);
    
    dimVals( dimVals < length(u0) ) = [];
    
    % Apply the discretistion dimension on all pieces:
    disc.dimension = repmat(dimVals(1), 1, numel(disc.domain)-1);
    dimVals(1) = [];
else
    % A discretisation is given:
    disc = discType;
    
    % TODO: Check discretisation is valid for the given L and u0!
    
    % Initialise dimVals;
    dimVals = max(disc.dimension);
end

if ( isempty(L.continuity) )
     % Apply continuity conditions:
     disc = deriveContinuity(disc);
end

% Initialise happiness:
numInt = disc.numIntervals;
isDone = false(1, numInt);

if isa(u0,'chebfun')
    u0 = chebmatrix({u0}); 
end

%% Loop over a finer and finer grid until happy:
for dim = dimVals

    % Discretize the operator (incl. constraints/continuity):
    E = expm(disc,t);
    
    % Discretize the initial condition.
    v0 = cellfun(@(x) blockMatrix(disc,x),u0.blocks,'uniform',false);
    v0 = cell2mat(v0);

    % Propagate.
    v = E*v0;
    
    % Convert the different components into cells
    u = partition(disc,v);
   
    % Test the happieness of the function pieces:
    [isDone, epsLevel] = testConvergence(disc, u(isFun));
    
    if ( all(isDone) )
        break
    else
        % Update the discretistion dimension on unhappy pieces:
        disc.dimension(~isDone) = dim;
    end
    
end

if ( ~all(isDone) )
    warning('LINOP:expm:NoConverge', ...
        'Matrix exponential may not have converged.')
end

%% Tidy the solution for output:
% The variable u is a cell array with the different components of the solution.
% Because each function component may be piecewise defined, we will loop through
% one by one.
for k = find( isFun )
    u{k} = disc.toFunction(u{k}); 
%     u{k} = simplify(u{k}, epsLevel);
end

% Convert to chebmatrix
u = chebmatrix(u);


end
